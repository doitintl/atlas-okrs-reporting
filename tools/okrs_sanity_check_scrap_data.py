#!/usr/bin/env python3
"""
Enhanced OKRs Sanity Check Script

This script performs a comprehensive sanity check on OKRs from the CSV generated by the recursive method,
focusing only on team members from teams.csv and adding two new checks:
1. Progress Type should be ATTACHED_METRIC (has a metric)
2. Lineage should be populated

Usage:
    python okrs_sanity_check_scrap_data.py [--file <csv_file>] [--cloud]
    python okrs_sanity_check_scrap_data.py -f scraped/export-20250706_102541_processed.csv
    python okrs_sanity_check_scrap_data.py --cloud

Arguments:
    --file, -f    Specify the CSV file to analyze (optional)
                  If not provided, uses the most recent file in scraped/
    --cloud, -c   Download and analyze the latest file from Cloud Storage bucket
                  Uses GCS_BUCKET_NAME environment variable (optional, defaults to ${PROJECT_ID}-okrs-data)

Dependencies are managed in pyproject.toml. Install with: uv sync
"""

import pandas as pd
from tabulate import tabulate
import os
import argparse
import tempfile

try:
    from google.cloud import storage
    CLOUD_STORAGE_AVAILABLE = True
except ImportError:
    CLOUD_STORAGE_AVAILABLE = False

# Config
TEAMS_CSV = "data/teams.csv"
LATEST_CSV_PATTERN = "scraped/export-*_processed*.csv"

def find_latest_csv():
    """Find the most recent processed CSV file"""
    import glob
    csv_files = glob.glob(LATEST_CSV_PATTERN)
    if not csv_files:
        raise FileNotFoundError(f"No CSV files found matching pattern: {LATEST_CSV_PATTERN}")
    
    # Sort by modification time and get the most recent
    latest_file = max(csv_files, key=os.path.getmtime)
    return latest_file

def load_team_members():
    """Load team members from teams.csv"""
    if not os.path.exists(TEAMS_CSV):
        raise FileNotFoundError(f"Teams file not found: {TEAMS_CSV}")
    
    teams_df = pd.read_csv(TEAMS_CSV)
    team_members = set(teams_df['name'].str.strip())
    return teams_df, team_members

def download_latest_from_cloud():
    """Download the latest OKRs CSV file from Cloud Storage"""
    if not CLOUD_STORAGE_AVAILABLE:
        raise ImportError("google-cloud-storage not available. Install with: pip install google-cloud-storage")
    
    # Get bucket name - either from env var or compose from project ID
    bucket_name = os.getenv('GCS_BUCKET_NAME')
    if not bucket_name:
        project_id = os.getenv('GOOGLE_CLOUD_PROJECT')
        if not project_id:
            # Try to get from gcloud config
            try:
                import subprocess
                result = subprocess.run(['gcloud', 'config', 'get-value', 'project'], 
                                      capture_output=True, text=True, check=True)
                project_id = result.stdout.strip()
            except (subprocess.CalledProcessError, FileNotFoundError):
                raise ValueError("Cannot determine project ID. Set GOOGLE_CLOUD_PROJECT or GCS_BUCKET_NAME environment variable")
        
        bucket_name = f"{project_id}-okrs-data"
    
    print(f"‚òÅÔ∏è Connecting to Cloud Storage bucket: {bucket_name}")
    
    try:
        client = storage.Client()
        bucket = client.bucket(bucket_name)
        
        # List all CSV files in the okrs/ prefix
        blobs = list(bucket.list_blobs(prefix="okrs/export-"))
        
        # Filter for processed CSV files
        csv_blobs = [blob for blob in blobs if blob.name.endswith('_processed.csv')]
        
        if not csv_blobs:
            raise FileNotFoundError("No processed CSV files found in Cloud Storage bucket")
        
        # Sort by creation time and get the most recent
        latest_blob = max(csv_blobs, key=lambda b: b.time_created)
        
        print(f"üìÅ Latest file found: {latest_blob.name}")
        print(f"üìÖ Created: {latest_blob.time_created}")
        
        # Download content as string
        csv_content = latest_blob.download_as_text()
        
        # Create a temporary file
        temp_file = tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False)
        temp_file.write(csv_content)
        temp_file.close()
        
        print(f"‚¨áÔ∏è Downloaded to temporary file: {temp_file.name}")
        return temp_file.name, latest_blob.name
        
    except Exception as e:
        raise Exception(f"Error downloading from Cloud Storage: {e}")

def is_empty_or_null(value):
    """
    Check if a value is empty, null, nan, or None
    """
    if value is None:
        return True
    
    # Convert to string and strip whitespace
    str_value = str(value).strip().lower()
    
    # Check for empty, null, nan, or none values
    return str_value in ['', 'null', 'nan', 'none', 'na']

def enhanced_okr_sanity_check(row):
    """
    Enhanced sanity check for OKRs with additional requirements:
    - Target Date: not empty
    - Teams: not empty  
    - Parent Goal: not empty
    - Owner: not empty
    - Progress Type: should be ATTACHED_METRIC (NEW)
    - Lineage: should be populated (NEW)
    """
    missing = []
    
    # Original checks with improved validation
    if is_empty_or_null(row.get('Target Date')):
        missing.append('Target Date')
    if is_empty_or_null(row.get('Teams')):
        missing.append('Teams')
    if is_empty_or_null(row.get('Parent Goal')):
        missing.append('Parent Goal')
    if is_empty_or_null(row.get('Owner')):
        missing.append('Owner')
    
    # NEW checks
    progress_type = str(row.get('Progress Type', '')).strip()
    if is_empty_or_null(progress_type) or progress_type == 'NONE':
        missing.append('Progress Type (Metric)')
    
    if is_empty_or_null(row.get('Lineage')):
        missing.append('Lineage')
    
    return missing

def checkmark(val):
    """Return checkmark or X based on boolean value"""
    return '‚úÖ' if val else '‚ùå'

def find_aggregation_candidates(okrs_df, team_okrs):
    """
    Find parent goals without metrics that have sub-goals with metrics.
    These are candidates for AVERAGE_ROLLUP aggregation.
    """
    candidates = []
    
    # Build parent-child mapping for all goals (not just team members)
    goal_key_to_name = {}
    goal_key_to_owner = {}
    goal_key_to_progress_type = {}
    parent_to_children = {}
    
    for _, row in okrs_df.iterrows():
        goal_key = str(row.get('Goal Key', '')).strip()
        goal_name = str(row.get('Name', '')).strip()
        owner = str(row.get('Owner', '')).strip()
        parent_goal = str(row.get('Parent Goal', '')).strip()
        progress_type = str(row.get('Progress Type', '')).strip()
        
        if goal_key:
            goal_key_to_name[goal_key] = goal_name
            goal_key_to_owner[goal_key] = owner
            goal_key_to_progress_type[goal_key] = progress_type
            
            if not is_empty_or_null(parent_goal):
                if parent_goal not in parent_to_children:
                    parent_to_children[parent_goal] = []
                parent_to_children[parent_goal].append(goal_key)
    
    # Check each team member's goal to see if it's a parent without metrics
    for _, team_goal in team_okrs.iterrows():
        goal_key = str(team_goal.get('Goal Key', '')).strip()
        goal_name = str(team_goal.get('Name', '')).strip()
        owner = str(team_goal.get('Owner', '')).strip()
        progress_type = str(team_goal.get('Progress Type', '')).strip()
        
        # Skip if this goal already has a metric
        if not is_empty_or_null(progress_type) and progress_type != 'NONE':
            continue
        
        # Check if this goal has children
        children = parent_to_children.get(goal_key, [])
        if not children:
            continue  # Not a parent goal
        
        # Count children and children with metrics
        children_with_metrics = 0
        for child_key in children:
            child_progress_type = goal_key_to_progress_type.get(child_key, '')
            if not is_empty_or_null(child_progress_type) and child_progress_type != 'NONE':
                children_with_metrics += 1
        
        # Determine if aggregation is possible
        can_aggregate = '‚úÖ' if children_with_metrics > 0 else '‚ùå'
        
        candidates.append({
            'owner': owner,
            'goal_name': goal_name,
            'goal_key': goal_key,
            'sub_goals_count': len(children),
            'sub_goals_with_metrics': children_with_metrics,
            'can_aggregate': can_aggregate
        })
    
    # Sort by number of sub-goals with metrics (descending) for better prioritization
    candidates.sort(key=lambda x: x['sub_goals_with_metrics'], reverse=True)
    
    return candidates

def get_malformed_okrs_and_teams(file: str = None, cloud: bool = False):
    """
    Returns the DataFrame of malformed OKRs for team members and the teams DataFrame.
    Args:
        file (str): Path to the CSV file to analyze (optional)
        cloud (bool): Whether to download the latest file from Cloud Storage
    Returns:
        malformed_team_okrs (pd.DataFrame): DataFrame of malformed OKRs for team members
        teams_df (pd.DataFrame): DataFrame of teams
    """
    # Load team members
    teams_df, team_members = load_team_members()

    # Find and load CSV
    temp_file_to_cleanup = None
    try:
        if cloud:
            csv_file, _ = download_latest_from_cloud()
            temp_file_to_cleanup = csv_file
        elif file:
            csv_file = file
            if not os.path.exists(csv_file):
                raise FileNotFoundError(f"Specified file not found: {csv_file}")
        else:
            csv_file = find_latest_csv()
        
        if not csv_file:
            raise FileNotFoundError("No CSV file found")

        print(f"üìä Loading data from: {csv_file}")
        df = pd.read_csv(csv_file)

        # Ensure EntityId column is present (for backward compatibility)
        if 'EntityId' not in df.columns:
            print("‚ö†Ô∏è Warning: EntityId column not found in CSV. This may affect comment posting functionality.")
            df['EntityId'] = None

        okrs_df = df.copy() # Renamed df to okrs_df to avoid conflict with the function's return value
    finally:
        if temp_file_to_cleanup and os.path.exists(temp_file_to_cleanup):
            os.unlink(temp_file_to_cleanup)

    # Filter only team members' OKRs
    team_okrs = okrs_df[okrs_df['Owner'].str.strip().isin(team_members)].copy()
    if team_okrs.empty:
        return pd.DataFrame(), teams_df

    # Perform enhanced sanity check
    team_okrs['sanity_missing'] = team_okrs.apply(enhanced_okr_sanity_check, axis=1)
    team_okrs['is_sane'] = team_okrs['sanity_missing'].apply(lambda x: len(x) == 0)

    # Get malformed OKRs
    malformed_team_okrs = team_okrs[~team_okrs['is_sane']].copy()
    return malformed_team_okrs, teams_df

def main():
    # Parse command line arguments
    parser = argparse.ArgumentParser(description='Enhanced OKRs Sanity Check')
    parser.add_argument('--file', '-f', type=str, help='Specify the CSV file to analyze (optional)')
    parser.add_argument('--cloud', '-c', action='store_true', help='Download and analyze the latest file from Cloud Storage bucket')
    args = parser.parse_args()
    
    # Validate arguments
    if args.file and args.cloud:
        print("‚ùå Error: Cannot use both --file and --cloud options simultaneously")
        return
    
    print("üîç Enhanced OKRs Sanity Check")
    print("=" * 60)
    print()
    
    # Load team members
    print("üìã Loading team members...")
    try:
        teams_df, team_members = load_team_members()
        print(f"‚úÖ Loaded {len(team_members)} team members from {len(teams_df['team'].unique())} teams")
    except Exception as e:
        print(f"‚ùå Error loading team members: {e}")
        return
    print()
    
    # Find and load CSV
    print("üìä Loading OKRs CSV...")
    temp_file_to_cleanup = None
    try:
        if args.cloud:
            # Download from Cloud Storage
            csv_file, cloud_filename = download_latest_from_cloud()
            temp_file_to_cleanup = csv_file
            print(f"‚úÖ Using latest file from cloud: {cloud_filename}")
        elif args.file:
            # Use specified file
            csv_file = args.file
            if not os.path.exists(csv_file):
                print(f"‚ùå Specified file not found: {csv_file}")
                return
            print(f"‚úÖ Using specified file: {csv_file}")
        else:
            # Auto-detect latest local file
            csv_file = find_latest_csv()
            print(f"‚úÖ Using latest local file: {csv_file}")
        
        okrs_df = pd.read_csv(csv_file)
        print(f"üìä Total OKRs in CSV: {len(okrs_df)}")
    except Exception as e:
        print(f"‚ùå Error loading OKRs data: {e}")
        # Cleanup temp file if it exists
        if temp_file_to_cleanup and os.path.exists(temp_file_to_cleanup):
            os.unlink(temp_file_to_cleanup)
        return
    
    # Filter only team members' OKRs
    team_okrs = okrs_df[okrs_df['Owner'].str.strip().isin(team_members)].copy()
    print(f"üéØ OKRs from team members: {len(team_okrs)}")
    print()
    
    if team_okrs.empty:
        print("‚ùå No OKRs found for team members!")
        return
    
    # Perform enhanced sanity check
    print("üîç Performing enhanced sanity check...")
    team_okrs['sanity_missing'] = team_okrs.apply(enhanced_okr_sanity_check, axis=1)
    team_okrs['is_sane'] = team_okrs['sanity_missing'].apply(lambda x: len(x) == 0)
    
    # Calculate statistics
    total_okrs = len(team_okrs)
    sane_okrs = len(team_okrs[team_okrs['is_sane']])
    malformed_okrs = total_okrs - sane_okrs
    
    print(f"üìä SUMMARY:")
    print(f"   Total OKRs: {total_okrs}")
    print(f"   ‚úÖ Healthy OKRs: {sane_okrs} ({sane_okrs/total_okrs*100:.1f}%)")
    print(f"   ‚ùå Malformed OKRs: {malformed_okrs} ({malformed_okrs/total_okrs*100:.1f}%)")
    print()
    
    # Show statistics by team
    print("üìã OKRs Health by Team:")
    print("-" * 40)
    
    team_stats = []
    for team in teams_df['team'].unique():
        team_members_list = teams_df[teams_df['team'] == team]['name'].tolist()
        team_okrs_filtered = team_okrs[team_okrs['Owner'].str.strip().isin(team_members_list)]
        
        if not team_okrs_filtered.empty:
            team_total = len(team_okrs_filtered)
            team_sane = len(team_okrs_filtered[team_okrs_filtered['is_sane']])
            team_malformed = team_total - team_sane
            health_percentage = (team_sane / team_total * 100) if team_total > 0 else 0
            
            team_stats.append({
                'Team': team,
                'Total OKRs': team_total,
                'Healthy': team_sane,
                'Malformed': team_malformed,
                'Health %': f"{health_percentage:.1f}%"
            })
    
    if team_stats:
        team_stats_df = pd.DataFrame(team_stats)
        
        # Calculate totals row
        total_okrs = team_stats_df['Total OKRs'].sum()
        total_healthy = team_stats_df['Healthy'].sum()
        total_malformed = team_stats_df['Malformed'].sum()
        total_health_percentage = (total_healthy / total_okrs * 100) if total_okrs > 0 else 0
        
        # Add totals row
        total_row = pd.DataFrame([{
            'Team': 'TOTAL',
            'Total OKRs': total_okrs,
            'Healthy': total_healthy,
            'Malformed': total_malformed,
            'Health %': f"{total_health_percentage:.1f}%"
        }])
        
        team_stats_df = pd.concat([team_stats_df, total_row], ignore_index=True)
        
        print(tabulate(team_stats_df, headers="keys", tablefmt="fancy_grid", showindex=False))
        print()
    
    # Show Progress Type distribution for malformed OKRs
    print("üîç Progress Type Distribution (Malformed OKRs):")
    print("-" * 50)
    
    malformed_okrs_data = team_okrs[~team_okrs['is_sane']]
    if not malformed_okrs_data.empty:
        progress_type_counts = malformed_okrs_data['Progress Type'].value_counts()
        
        progress_breakdown = []
        for progress_type, count in progress_type_counts.items():
            percentage = (count / len(malformed_okrs_data) * 100)
            progress_breakdown.append({
                'Progress Type': progress_type if progress_type and str(progress_type).strip() != 'nan' else 'Not Set/Empty',
                'Count': count,
                'Percentage': f"{percentage:.1f}%"
            })
        
        progress_df = pd.DataFrame(progress_breakdown)
        print(tabulate(progress_df, headers="keys", tablefmt="fancy_grid", showindex=False))
        print()
        
        # Also show what Progress Types the healthy OKRs have
        print("‚úÖ Progress Type Distribution (Healthy OKRs):")
        print("-" * 45)
        
        healthy_okrs_data = team_okrs[team_okrs['is_sane']]
        if not healthy_okrs_data.empty:
            healthy_progress_counts = healthy_okrs_data['Progress Type'].value_counts()
            
            healthy_breakdown = []
            for progress_type, count in healthy_progress_counts.items():
                percentage = (count / len(healthy_okrs_data) * 100)
                healthy_breakdown.append({
                    'Progress Type': progress_type if progress_type and str(progress_type).strip() != 'nan' else 'Not Set/Empty',
                    'Count': count,
                    'Percentage': f"{percentage:.1f}%"
                })
            
            healthy_progress_df = pd.DataFrame(healthy_breakdown)
            print(tabulate(healthy_progress_df, headers="keys", tablefmt="fancy_grid", showindex=False))
            print()
    else:
        print("No malformed OKRs found!")
        print()
    
    # Show malformed OKRs details
    malformed_team_okrs = team_okrs[~team_okrs['is_sane']]
    if not malformed_team_okrs.empty:
        print(f"‚ùå Malformed OKRs Details ({len(malformed_team_okrs)} total):")
        print("-" * 60)
        
        malformed_table = []
        for _, row in malformed_team_okrs.iterrows():
            # Check each requirement
            has_target_date = 'Target Date' not in row['sanity_missing']
            has_teams = 'Teams' not in row['sanity_missing'] 
            has_parent = 'Parent Goal' not in row['sanity_missing']
            has_owner = 'Owner' not in row['sanity_missing']
            has_metric = 'Progress Type (Metric)' not in row['sanity_missing']
            has_lineage = 'Lineage' not in row['sanity_missing']
            
            malformed_table.append([
                row.get('Owner', ''),
                (row.get('Name', '')[:40] + "...") if len(str(row.get('Name', ''))) > 40 else row.get('Name', ''),
                checkmark(has_target_date),
                checkmark(has_teams),
                checkmark(has_parent),
                checkmark(has_owner),
                checkmark(has_metric),
                checkmark(has_lineage)
            ])
        
        headers = [
            "Owner", 
            "OKR Name", 
            "Target Date", 
            "Teams", 
            "Parent Goal", 
            "Owner (OKR)",
            "Has Metric",
            "Has Lineage"
        ]
        
        print(tabulate(
            malformed_table,
            headers=headers,
            tablefmt="fancy_grid",
            showindex=False
        ))
        print()
    else:
        print("üéâ All OKRs for team members pass the enhanced sanity check!")
        print()
    
    # NEW: Show parent goals without metrics that have sub-goals (aggregation candidates)
    print("üìä Parent Goals Without Metrics (Aggregation Candidates):")
    print("-" * 65)
    
    # Build hierarchy to identify parent-child relationships
    aggregation_candidates = find_aggregation_candidates(okrs_df, team_okrs)
    
    if aggregation_candidates:
        agg_table = []
        for candidate in aggregation_candidates:
            agg_table.append([
                candidate['owner'],
                (candidate['goal_name'][:50] + "...") if len(candidate['goal_name']) > 50 else candidate['goal_name'],
                candidate['sub_goals_count'],
                candidate['sub_goals_with_metrics'],
                candidate['can_aggregate']
            ])
        
        agg_headers = [
            "Owner",
            "Parent Goal Name", 
            "Sub-Goals",
            "Sub-Goals w/ Metrics",
            "Can Aggregate"
        ]
        
        print(tabulate(
            agg_table,
            headers=agg_headers,
            tablefmt="fancy_grid",
            showindex=False
        ))
        
        # Summary recommendation
        can_aggregate_count = len([c for c in aggregation_candidates if c['can_aggregate'] == '‚úÖ'])
        print(f"\nüí° RECOMMENDATION: {can_aggregate_count} parent goals can enable AVERAGE_ROLLUP to aggregate metrics from sub-goals")
        print("   This would automatically calculate progress based on child goals' metrics.")
        print()
    else:
        print("‚úÖ No parent goals without metrics found (or all sub-goals lack metrics too)")
        print()
    
    # Show people without OKRs
    print("üë• People without OKRs by Team:")
    print("-" * 40)
    
    people_with_okrs = set(team_okrs['Owner'].str.strip())
    missing_okrs_by_team = []
    
    for team in teams_df['team'].unique():
        team_members_list = set(teams_df[teams_df['team'] == team]['name'].str.strip())
        people_without_okrs = team_members_list - people_with_okrs
        
        if people_without_okrs:
            missing_okrs_by_team.append([f"üìã {team}", ""])
            for person in sorted(people_without_okrs):
                missing_okrs_by_team.append([f"   ‚Ä¢ {person}", ""])
            missing_okrs_by_team.append(["", ""])  # Separator
    
    if missing_okrs_by_team:
        # Remove last separator
        if missing_okrs_by_team[-1] == ["", ""]:
            missing_okrs_by_team.pop()
        
        print(tabulate(
            missing_okrs_by_team,
            headers=["Team / Person", ""],
            tablefmt="fancy_grid",
            showindex=False
        ))
    else:
        print("üéâ All team members have OKRs!")
    
    print()
    print("‚úÖ Enhanced sanity check completed!")
    
    # Cleanup temporary file if it exists
    if temp_file_to_cleanup and os.path.exists(temp_file_to_cleanup):
        os.unlink(temp_file_to_cleanup)
        print("üóëÔ∏è Temporary file cleaned up")

if __name__ == "__main__":
    main() 